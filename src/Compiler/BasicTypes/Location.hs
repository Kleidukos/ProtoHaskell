{-# LANGUAGE StrictData #-}

module Compiler.BasicTypes.Location where

import Compiler.BasicTypes.SrcLoc
import Data.IntMap.Strict (IntMap)
import Data.IntMap.Strict qualified as IntMap
import Data.Maybe (fromJust)

type NodeID = Int

data LocationMap = LocationMap
  { path :: FilePath
  , spans :: IntMap SrcSpan
  }

insertLocation :: NodeID -> SrcSpan -> LocationMap -> LocationMap
insertLocation nodeId span' (LocationMap path m) =
  LocationMap path (IntMap.insert nodeId span' m)

-- NOTE: this assumes the node ID is generated by parsing the same file that resulted in the LocationMap.
lookupLocation :: LocationMap -> NodeID -> SrcSpan
lookupLocation (LocationMap _path m) nodeId =
  fromJust $ IntMap.lookup nodeId m

-- -- Finds the most specific NodeID (that corresponds with the smallest span)
-- lookupNodeID :: LocationMap -> Int -> Maybe NodeID
-- lookupNodeID (LocationMap _ m) offset =
--   m
--     & IntMap.toList
--     & List.filter (containsOffset . snd)
--     -- Just sorting by span size is not enough, sometimes we have two spans
--     -- with identical widths (e.g. with parentheses). The last one will always
--     -- be the node ID that belongs to the smallest (most specific) node.
--     & sortWith (spanSize . snd &&& negate . fst)
--     & viaNonEmpty NonEmpty.head
--     & fmap fst
--   where
--     containsOffset span' =
--       offset >= beginPos span' && offset < endPos span'
--
--     spanSize span' =
--       endPos span' - beginPos span'
--
-- viaNonEmpty :: (NonEmpty a -> b) -> [a] -> Maybe b
-- viaNonEmpty f = fmap f . NonEmpty.nonEmpty
-- {-# INLINE viaNonEmpty #-}
